
2. button click and double click and hold.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00802800  00802800  00000358  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000002e4  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000000e  00802800  00802800  00000358  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000358  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000388  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000060  00000000  00000000  000003c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002dc6  00000000  00000000  00000428  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002549  00000000  00000000  000031ee  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000520  00000000  00000000  00005737  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000d0  00000000  00000000  00005c58  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000014e0  00000000  00000000  00005d28  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000000cb  00000000  00000000  00007208  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000040  00000000  00000000  000072d3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 50 00 	jmp	0xa0	; 0xa0 <__ctors_end>
   4:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
   8:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
   c:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  10:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  14:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  18:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  1c:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  20:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  24:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  28:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  2c:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  30:	0c 94 1b 01 	jmp	0x236	; 0x236 <__vector_12>
  34:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  38:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  3c:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  40:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  44:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  48:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  4c:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  50:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  54:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  58:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  5c:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  60:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  64:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  68:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  6c:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  70:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  74:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  78:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  7c:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  80:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  84:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  88:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  8c:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  90:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  94:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  98:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>
  9c:	0c 94 62 00 	jmp	0xc4	; 0xc4 <__bad_interrupt>

000000a0 <__ctors_end>:
  a0:	11 24       	eor	r1, r1
  a2:	1f be       	out	0x3f, r1	; 63
  a4:	cf ef       	ldi	r28, 0xFF	; 255
  a6:	cd bf       	out	0x3d, r28	; 61
  a8:	df e3       	ldi	r29, 0x3F	; 63
  aa:	de bf       	out	0x3e, r29	; 62

000000ac <__do_clear_bss>:
  ac:	28 e2       	ldi	r18, 0x28	; 40
  ae:	a0 e0       	ldi	r26, 0x00	; 0
  b0:	b8 e2       	ldi	r27, 0x28	; 40
  b2:	01 c0       	rjmp	.+2      	; 0xb6 <.do_clear_bss_start>

000000b4 <.do_clear_bss_loop>:
  b4:	1d 92       	st	X+, r1

000000b6 <.do_clear_bss_start>:
  b6:	ae 30       	cpi	r26, 0x0E	; 14
  b8:	b2 07       	cpc	r27, r18
  ba:	e1 f7       	brne	.-8      	; 0xb4 <.do_clear_bss_loop>
  bc:	0e 94 ff 00 	call	0x1fe	; 0x1fe <main>
  c0:	0c 94 70 01 	jmp	0x2e0	; 0x2e0 <_exit>

000000c4 <__bad_interrupt>:
  c4:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000c8 <BUTTON_LED_GPIO_Init>:
 * PF5 : LED
 * PF6 : BUTTON
 */
void BUTTON_LED_GPIO_Init(void)
{
	PORTF.DIRSET = PIN5_bm;
  c8:	e0 ea       	ldi	r30, 0xA0	; 160
  ca:	f4 e0       	ldi	r31, 0x04	; 4
  cc:	80 e2       	ldi	r24, 0x20	; 32
  ce:	81 83       	std	Z+1, r24	; 0x01
	PORTF.DIRCLR = PIN6_bm;
  d0:	90 e4       	ldi	r25, 0x40	; 64
  d2:	92 83       	std	Z+2, r25	; 0x02
	PORTF.OUTSET = PIN5_bm;
  d4:	85 83       	std	Z+5, r24	; 0x05
	PORTF.PIN6CTRL |= PORT_PULLUPEN_bm;
  d6:	86 89       	ldd	r24, Z+22	; 0x16
  d8:	88 60       	ori	r24, 0x08	; 8
  da:	86 8b       	std	Z+22, r24	; 0x16
  dc:	08 95       	ret

000000de <buttonISR>:
	static buttonState_t buttonState = BUTTON_IDLE;
	static uint16_t buttonPressTimeCount = 0;
	static uint16_t LastPress, CurrentPress = 0;
	static uint16_t clock = 0;

	clock++;
  de:	20 91 07 28 	lds	r18, 0x2807	; 0x802807 <clock.2948>
  e2:	30 91 08 28 	lds	r19, 0x2808	; 0x802808 <clock.2948+0x1>
  e6:	2f 5f       	subi	r18, 0xFF	; 255
  e8:	3f 4f       	sbci	r19, 0xFF	; 255
  ea:	20 93 07 28 	sts	0x2807, r18	; 0x802807 <clock.2948>
  ee:	30 93 08 28 	sts	0x2808, r19	; 0x802808 <clock.2948+0x1>

	if(LastPress && LastPress != CurrentPress && (CurrentPress - LastPress) < 80) { buttonFlag.DoublePress = true; }
  f2:	80 91 05 28 	lds	r24, 0x2805	; 0x802805 <LastPress.2946>
  f6:	90 91 06 28 	lds	r25, 0x2806	; 0x802806 <LastPress.2946+0x1>
  fa:	00 97       	sbiw	r24, 0x00	; 0
  fc:	79 f0       	breq	.+30     	; 0x11c <__EEPROM_REGION_LENGTH__+0x1c>
  fe:	40 91 03 28 	lds	r20, 0x2803	; 0x802803 <CurrentPress.2947>
 102:	50 91 04 28 	lds	r21, 0x2804	; 0x802804 <CurrentPress.2947+0x1>
 106:	84 17       	cp	r24, r20
 108:	95 07       	cpc	r25, r21
 10a:	41 f0       	breq	.+16     	; 0x11c <__EEPROM_REGION_LENGTH__+0x1c>
 10c:	48 1b       	sub	r20, r24
 10e:	59 0b       	sbc	r21, r25
 110:	40 35       	cpi	r20, 0x50	; 80
 112:	51 05       	cpc	r21, r1
 114:	18 f4       	brcc	.+6      	; 0x11c <__EEPROM_REGION_LENGTH__+0x1c>
 116:	81 e0       	ldi	r24, 0x01	; 1
 118:	80 93 0a 28 	sts	0x280A, r24	; 0x80280a <buttonFlag+0x1>
	if(!buttonFlag.Hold && buttonPressTimeCount >= 200) buttonFlag.Hold = true;
 11c:	80 91 0b 28 	lds	r24, 0x280B	; 0x80280b <buttonFlag+0x2>
 120:	81 11       	cpse	r24, r1
 122:	0a c0       	rjmp	.+20     	; 0x138 <__EEPROM_REGION_LENGTH__+0x38>
 124:	80 91 01 28 	lds	r24, 0x2801	; 0x802801 <buttonPressTimeCount.2945>
 128:	90 91 02 28 	lds	r25, 0x2802	; 0x802802 <buttonPressTimeCount.2945+0x1>
 12c:	88 3c       	cpi	r24, 0xC8	; 200
 12e:	91 05       	cpc	r25, r1
 130:	18 f0       	brcs	.+6      	; 0x138 <__EEPROM_REGION_LENGTH__+0x38>
 132:	81 e0       	ldi	r24, 0x01	; 1
 134:	80 93 0b 28 	sts	0x280B, r24	; 0x80280b <buttonFlag+0x2>
	switch (buttonState)
 138:	80 91 00 28 	lds	r24, 0x2800	; 0x802800 <__DATA_REGION_ORIGIN__>
 13c:	81 30       	cpi	r24, 0x01	; 1
 13e:	71 f0       	breq	.+28     	; 0x15c <__EEPROM_REGION_LENGTH__+0x5c>
 140:	28 f0       	brcs	.+10     	; 0x14c <__EEPROM_REGION_LENGTH__+0x4c>
 142:	82 30       	cpi	r24, 0x02	; 2
 144:	f1 f0       	breq	.+60     	; 0x182 <__EEPROM_REGION_LENGTH__+0x82>
 146:	83 30       	cpi	r24, 0x03	; 3
 148:	b1 f1       	breq	.+108    	; 0x1b6 <__EEPROM_REGION_LENGTH__+0xb6>
 14a:	08 95       	ret
	{
		case BUTTON_IDLE :
			if(USER_BUTTON_ON) buttonState++;
 14c:	90 91 a8 04 	lds	r25, 0x04A8	; 0x8004a8 <__TEXT_REGION_LENGTH__+0x7f44a8>
 150:	96 fd       	sbrc	r25, 6
 152:	41 c0       	rjmp	.+130    	; 0x1d6 <__EEPROM_REGION_LENGTH__+0xd6>
 154:	8f 5f       	subi	r24, 0xFF	; 255
 156:	80 93 00 28 	sts	0x2800, r24	; 0x802800 <__DATA_REGION_ORIGIN__>
 15a:	08 95       	ret
			break;
		case BUTTON_PRESSING :
			if(USER_BUTTON_ON) { buttonFlag.OnPress = true; buttonState++; CurrentPress = clock; }
 15c:	90 91 a8 04 	lds	r25, 0x04A8	; 0x8004a8 <__TEXT_REGION_LENGTH__+0x7f44a8>
 160:	96 fd       	sbrc	r25, 6
 162:	0b c0       	rjmp	.+22     	; 0x17a <__EEPROM_REGION_LENGTH__+0x7a>
 164:	91 e0       	ldi	r25, 0x01	; 1
 166:	90 93 09 28 	sts	0x2809, r25	; 0x802809 <buttonFlag>
 16a:	8f 5f       	subi	r24, 0xFF	; 255
 16c:	80 93 00 28 	sts	0x2800, r24	; 0x802800 <__DATA_REGION_ORIGIN__>
 170:	20 93 03 28 	sts	0x2803, r18	; 0x802803 <CurrentPress.2947>
 174:	30 93 04 28 	sts	0x2804, r19	; 0x802804 <CurrentPress.2947+0x1>
 178:	08 95       	ret
			else buttonState--;
 17a:	81 50       	subi	r24, 0x01	; 1
 17c:	80 93 00 28 	sts	0x2800, r24	; 0x802800 <__DATA_REGION_ORIGIN__>
 180:	08 95       	ret
			break;
		case BUTTON_PRESSED :
			if(!USER_BUTTON_ON) buttonState++;
 182:	90 91 a8 04 	lds	r25, 0x04A8	; 0x8004a8 <__TEXT_REGION_LENGTH__+0x7f44a8>
 186:	96 ff       	sbrs	r25, 6
 188:	04 c0       	rjmp	.+8      	; 0x192 <__EEPROM_REGION_LENGTH__+0x92>
 18a:	8f 5f       	subi	r24, 0xFF	; 255
 18c:	80 93 00 28 	sts	0x2800, r24	; 0x802800 <__DATA_REGION_ORIGIN__>
 190:	08 95       	ret
			else { buttonPressTimeCount++; LastPress = CurrentPress; }
 192:	80 91 01 28 	lds	r24, 0x2801	; 0x802801 <buttonPressTimeCount.2945>
 196:	90 91 02 28 	lds	r25, 0x2802	; 0x802802 <buttonPressTimeCount.2945+0x1>
 19a:	01 96       	adiw	r24, 0x01	; 1
 19c:	80 93 01 28 	sts	0x2801, r24	; 0x802801 <buttonPressTimeCount.2945>
 1a0:	90 93 02 28 	sts	0x2802, r25	; 0x802802 <buttonPressTimeCount.2945+0x1>
 1a4:	80 91 03 28 	lds	r24, 0x2803	; 0x802803 <CurrentPress.2947>
 1a8:	90 91 04 28 	lds	r25, 0x2804	; 0x802804 <CurrentPress.2947+0x1>
 1ac:	80 93 05 28 	sts	0x2805, r24	; 0x802805 <LastPress.2946>
 1b0:	90 93 06 28 	sts	0x2806, r25	; 0x802806 <LastPress.2946+0x1>
 1b4:	08 95       	ret
			break;
		case BUTTON_RELEASE :
			if(!USER_BUTTON_ON) { buttonFlag.OnPress = false; buttonState = BUTTON_IDLE; buttonPressTimeCount = 0; }
 1b6:	90 91 a8 04 	lds	r25, 0x04A8	; 0x8004a8 <__TEXT_REGION_LENGTH__+0x7f44a8>
 1ba:	96 ff       	sbrs	r25, 6
 1bc:	09 c0       	rjmp	.+18     	; 0x1d0 <__EEPROM_REGION_LENGTH__+0xd0>
 1be:	10 92 09 28 	sts	0x2809, r1	; 0x802809 <buttonFlag>
 1c2:	10 92 00 28 	sts	0x2800, r1	; 0x802800 <__DATA_REGION_ORIGIN__>
 1c6:	10 92 01 28 	sts	0x2801, r1	; 0x802801 <buttonPressTimeCount.2945>
 1ca:	10 92 02 28 	sts	0x2802, r1	; 0x802802 <buttonPressTimeCount.2945+0x1>
 1ce:	08 95       	ret
			else buttonState--;
 1d0:	81 50       	subi	r24, 0x01	; 1
 1d2:	80 93 00 28 	sts	0x2800, r24	; 0x802800 <__DATA_REGION_ORIGIN__>
 1d6:	08 95       	ret

000001d8 <CLK_Init>:
	}
}

void CLK_Init(void)
{
	CCP = CCP_IOREG_gc;
 1d8:	88 ed       	ldi	r24, 0xD8	; 216
 1da:	84 bf       	out	0x34, r24	; 52
	CLKCTRL.MCLKCTRLB = CLKCTRL_PDIV_4X_gc | CLKCTRL_PEN_bm;
 1dc:	83 e0       	ldi	r24, 0x03	; 3
 1de:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7f4061>
 1e2:	08 95       	ret

000001e4 <TCB0_Init>:
}

void TCB0_Init(void)
{
	TCB0.CCMP = 5000;
 1e4:	e0 e8       	ldi	r30, 0x80	; 128
 1e6:	fa e0       	ldi	r31, 0x0A	; 10
 1e8:	88 e8       	ldi	r24, 0x88	; 136
 1ea:	93 e1       	ldi	r25, 0x13	; 19
 1ec:	84 87       	std	Z+12, r24	; 0x0c
 1ee:	95 87       	std	Z+13, r25	; 0x0d
	TCB0.CTRLA |= TCB_ENABLE_bm;
 1f0:	80 81       	ld	r24, Z
 1f2:	81 60       	ori	r24, 0x01	; 1
 1f4:	80 83       	st	Z, r24
	TCB0.INTCTRL |= TCB_CAPT_bm;
 1f6:	85 81       	ldd	r24, Z+5	; 0x05
 1f8:	81 60       	ori	r24, 0x01	; 1
 1fa:	85 83       	std	Z+5, r24	; 0x05
 1fc:	08 95       	ret

000001fe <main>:

buttonFlag_t buttonFlag;

int main(void)
{
	CLK_Init();
 1fe:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <CLK_Init>
	TCB0_Init();
 202:	0e 94 f2 00 	call	0x1e4	; 0x1e4 <TCB0_Init>
	BUTTON_LED_GPIO_Init();
 206:	0e 94 64 00 	call	0xc8	; 0xc8 <BUTTON_LED_GPIO_Init>

	sei();
 20a:	78 94       	sei
	while (1)
	{
		if(buttonFlag.OnPress) {}
 20c:	e9 e0       	ldi	r30, 0x09	; 9
 20e:	f8 e2       	ldi	r31, 0x28	; 40
 210:	80 81       	ld	r24, Z
		if(buttonFlag.Hold) { buttonFlag.Hold = false; USER_LED_ON; }
 212:	82 81       	ldd	r24, Z+2	; 0x02
 214:	88 23       	and	r24, r24
 216:	29 f0       	breq	.+10     	; 0x222 <main+0x24>
 218:	10 92 0b 28 	sts	0x280B, r1	; 0x80280b <buttonFlag+0x2>
 21c:	80 e2       	ldi	r24, 0x20	; 32
 21e:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <__TEXT_REGION_LENGTH__+0x7f44a6>
		if(buttonFlag.DoublePress) { buttonFlag.DoublePress = false; USER_LED_OFF;}
 222:	80 91 0a 28 	lds	r24, 0x280A	; 0x80280a <buttonFlag+0x1>
 226:	88 23       	and	r24, r24
 228:	89 f3       	breq	.-30     	; 0x20c <main+0xe>
 22a:	10 92 0a 28 	sts	0x280A, r1	; 0x80280a <buttonFlag+0x1>
 22e:	80 e2       	ldi	r24, 0x20	; 32
 230:	80 93 a5 04 	sts	0x04A5, r24	; 0x8004a5 <__TEXT_REGION_LENGTH__+0x7f44a5>
 234:	eb cf       	rjmp	.-42     	; 0x20c <main+0xe>

00000236 <__vector_12>:
 *
 * goto) 자세한 버튼 상태 관리 구조는 button.h 의 buttonState_t 구조체를 확인하자.
 */

ISR(TCB0_INT_vect)
{
 236:	1f 92       	push	r1
 238:	0f 92       	push	r0
 23a:	0f b6       	in	r0, 0x3f	; 63
 23c:	0f 92       	push	r0
 23e:	11 24       	eor	r1, r1
 240:	2f 93       	push	r18
 242:	3f 93       	push	r19
 244:	4f 93       	push	r20
 246:	5f 93       	push	r21
 248:	6f 93       	push	r22
 24a:	7f 93       	push	r23
 24c:	8f 93       	push	r24
 24e:	9f 93       	push	r25
 250:	af 93       	push	r26
 252:	bf 93       	push	r27
 254:	ef 93       	push	r30
 256:	ff 93       	push	r31
	static uint16_t Cnt1000Hz = 0;
	uint8_t Cnt200Hz = (uint8_t)(Cnt1000Hz % 5);
 258:	40 91 0c 28 	lds	r20, 0x280C	; 0x80280c <Cnt1000Hz.2957>
 25c:	50 91 0d 28 	lds	r21, 0x280D	; 0x80280d <Cnt1000Hz.2957+0x1>
 260:	9a 01       	movw	r18, r20
 262:	ad ec       	ldi	r26, 0xCD	; 205
 264:	bc ec       	ldi	r27, 0xCC	; 204
 266:	0e 94 61 01 	call	0x2c2	; 0x2c2 <__umulhisi3>
 26a:	96 95       	lsr	r25
 26c:	87 95       	ror	r24
 26e:	96 95       	lsr	r25
 270:	87 95       	ror	r24
 272:	9c 01       	movw	r18, r24
 274:	22 0f       	add	r18, r18
 276:	33 1f       	adc	r19, r19
 278:	22 0f       	add	r18, r18
 27a:	33 1f       	adc	r19, r19
 27c:	82 0f       	add	r24, r18
 27e:	93 1f       	adc	r25, r19
	Cnt1000Hz++;
 280:	9a 01       	movw	r18, r20
 282:	2f 5f       	subi	r18, 0xFF	; 255
 284:	3f 4f       	sbci	r19, 0xFF	; 255
 286:	20 93 0c 28 	sts	0x280C, r18	; 0x80280c <Cnt1000Hz.2957>
 28a:	30 93 0d 28 	sts	0x280D, r19	; 0x80280d <Cnt1000Hz.2957+0x1>
	if(Cnt200Hz == 0) buttonISR();
 28e:	48 13       	cpse	r20, r24
 290:	02 c0       	rjmp	.+4      	; 0x296 <__vector_12+0x60>
 292:	0e 94 6f 00 	call	0xde	; 0xde <buttonISR>
	TCB0.INTFLAGS |= TCB_CAPT_bm;
 296:	e0 e8       	ldi	r30, 0x80	; 128
 298:	fa e0       	ldi	r31, 0x0A	; 10
 29a:	86 81       	ldd	r24, Z+6	; 0x06
 29c:	81 60       	ori	r24, 0x01	; 1
 29e:	86 83       	std	Z+6, r24	; 0x06
 2a0:	ff 91       	pop	r31
 2a2:	ef 91       	pop	r30
 2a4:	bf 91       	pop	r27
 2a6:	af 91       	pop	r26
 2a8:	9f 91       	pop	r25
 2aa:	8f 91       	pop	r24
 2ac:	7f 91       	pop	r23
 2ae:	6f 91       	pop	r22
 2b0:	5f 91       	pop	r21
 2b2:	4f 91       	pop	r20
 2b4:	3f 91       	pop	r19
 2b6:	2f 91       	pop	r18
 2b8:	0f 90       	pop	r0
 2ba:	0f be       	out	0x3f, r0	; 63
 2bc:	0f 90       	pop	r0
 2be:	1f 90       	pop	r1
 2c0:	18 95       	reti

000002c2 <__umulhisi3>:
 2c2:	a2 9f       	mul	r26, r18
 2c4:	b0 01       	movw	r22, r0
 2c6:	b3 9f       	mul	r27, r19
 2c8:	c0 01       	movw	r24, r0
 2ca:	a3 9f       	mul	r26, r19
 2cc:	70 0d       	add	r23, r0
 2ce:	81 1d       	adc	r24, r1
 2d0:	11 24       	eor	r1, r1
 2d2:	91 1d       	adc	r25, r1
 2d4:	b2 9f       	mul	r27, r18
 2d6:	70 0d       	add	r23, r0
 2d8:	81 1d       	adc	r24, r1
 2da:	11 24       	eor	r1, r1
 2dc:	91 1d       	adc	r25, r1
 2de:	08 95       	ret

000002e0 <_exit>:
 2e0:	f8 94       	cli

000002e2 <__stop_program>:
 2e2:	ff cf       	rjmp	.-2      	; 0x2e2 <__stop_program>
